# 딕셔너리에 대한 연습

# 딕셔너리는 key:value의 형태로 되어 있으며 각 값에는 숫자, 문자열, 리스트 등 여러 가지를 넣을 수 있다.
dict1 = { "key1" : 100, "key2" : "Hello", "key3" : 300 }
print(dict1)

# mutable(가변) immutable(불변) object
# 가변 객체, 불변 객체
'''
불변 객체 : 정수, 소수, 문자열, 튜플, 바이트형, frozenset형
가변 객체 : 리스트, 딕셔너리, set, 바이트 배열, 사용자 정의 class(사용자가 불변 객체로 정할 수도 있음)
'''
# 불변 객체
test1 = 30 # 정수형 변수 선언
print(test1) # 값 출력
print(id(test1)) # id함수 : 객체를 매개변수로 받아 해당 객체의 고유 주소 값을 반환
test1 = 50 # 값 변경
print(test1) # 값 출력
print(id(test1)) # 해당 변수의 고유 주소 출력
'''
위 코드의 결과를 보면 주소 값이 서로 다른 것을 확인할 수 있음
즉, 메모리 상에서 공간을 하나 만들어놓고 값만 바꾼 것이 아닌
값이 바뀌는 순간 새로운 공간을 하나 만들어서 그곳에 바뀐 값을 넣고
test1이 새로운 공간을 가리키고 있는 것임을 알 수 있음
그렇다면 결론적으로 이전에 메모리에 공간을 할당하여 넣은 값은 변한 것이 아니라
Gabage Collector가 회수하기 전까지는 변하지 않고 그대로 있다는 것을 알 수 있음
그래서 이러한 특성을 갖는 객체를 불변 객체라고 함
'''

# 가변 객체
test2 = [100, 200, 300] # 리스트 선언
print(test2) # 값 출력
print(id(test2)) # 고유 주소 출력
test2[0] = 400 # 값 변경
print(test2) # 값 출력
print(id(test2)) # 고유 주소 출력

'''
위 코드의 결과를 보면 주소 값이 바뀌지 않은 것을 확인할 수 있음
그렇다면 메모리상에 공간을 할당하고 각 공간에 넣은 값이 변경될 경우 그 안에 들어 있는
값만 바꾼다는 사실을 알 수 있음 그렇기에 이러한 특징을 가진 객체를 가변 객체라고 함
'''

# 딕셔너리는 키 값으로 가변 객체를 갖을 수 없다.

# dict2 = {"Hello" : 20, (20, 10) : 1000, [1, 2] : 2000} # list를 키로 사용할 경우 가변 객체이므로 TypeError: unhashable type: 'list' 에러가 난다.
# print(dict2)

dict3 = { "a" : 1, "a" : 2 }
# 딕셔너리는 키 값을 중복하여 사용할 수는 있지만 마지막에 쓰인 것으로 덮어 씌어진다.
print(dict3["a"])

dict4 = { "first" : 10, "second" : 20, "third" : 30 } # 딕셔너리 생성
print(dict4) # 값 출력
dict4["second"] = 50 # 키 값을 가지고 특정 인자 값 변경
print(dict4) # 값이 바뀐 것을 알 수 있음
# 딕셔너리는 정해진 순서가 없어서 인덱스로 조회가 가능하지 않고 키를 가지고 접근할 수 있음
# 그래서 시간 복잡도가 1이다.

dict4["fifth"] = 40 # 새로운 값을 추가하는 것은 이렇게 하면 된다.
print(dict4)

dict5 = {} # 빈 중괄호로 빈 딕셔너리를 선언할 수 있다.
print(type(dict5)) # 딕셔너리 타입임을 출력한다.


# 딕셔너리 변환
li1 = [["Key1", "data1"], ["Key2, data2"]]
dict6 = dict(li1)
print(dict6)