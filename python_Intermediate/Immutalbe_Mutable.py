ls = ["Hello", "Python"]
a = "Hello"

print(id(a)) # a가 가리키는 위치와
print(id(ls[0])) # ls[0]이 가리키는 위치는 같다.

ls[0] = "Hi" # ls[0]의 값을 변경하면
print(id(ls[0])) # 메모리에 Hi라는 값을 새로 만들고 해당 값을 id[0]으로 바인딩한다.

'''
여기서 들 수 있는 의문은 "리스트는 가변객체인데 왜 값을 바꾸지 않고 새롭게 메모리에 값을 할당한 뒤에 바인딩을 하는 것일까?" 이다.

잘 생각해보면 이렇다.

ls는 리스트가 맞다.
다만 ls[0]은 리스트가 아니라 문자열 객체를 바인딩한다.
그러므로 ls[0]은 불변 객체를 바인딩한다.
그러므로 불변 객체가 메모리에 값을 할당하여 바인딩 하는 방식을 따른다.

ls는 리스트가 맞으므로 아래와 같은 코드를 통해서 id값이 바뀌지 않는 것을 확인할 수 있다.

그리고 결국 ls의 입장에서 봤을 때 각 요소의 값이 바뀐다면 포인터들(ls[0], ls[1], ls[2], ...)이 가리키는 값이 바뀌는 것이므로
ls는 가변 객체가 맞다.
'''

ls2 = [1, 2, 3, 4]
print(ls2)
print(id(ls2))

ls2[0] = 11
print(ls2)
print(id(ls2))

# ls2의 id값이 변하지 않는 것을 확인할 수 있다.

'''
여기서 알아야 할 점은
python의 리스트는 단순 연결 리스트 구조가 아닌 동적 배열 구조를 갖기 때문에
우리가 생각하는 단순한 것과는 좀 차이가 있다.
https://seoyeonhwng.medium.com/%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EB%82%B4%EB%B6%80-%EA%B5%AC%EC%A1%B0-f04847b58286 참고
'''

'''
왜 교수님은 리스트를 힙으로 사용하면 안된다고 하신걸까?
내 생각에는 시간 복잡도 부분에서 좋지 않기 때문이다.
스택으로 사용하게 된다면 LIFO라서 데이터를 넣고 빼는데에는 마지막 포인터의 다음 포인터가 새로 만들어서 바인딩 하거나(PUSH)
마지막 포인터만 없애면 끝난다(POP)

하지만 힙은 FIFO구조라서 빼는데에 있어서 첫 번째 포인터가 가리키는 값을 인출한 다음에 그 뒤에 있는 포인터들을 모두 수정해야 하기 때문에
시간 복잡도가 크다. 그래서 성능이 별로 좋지 못해서 그렇다.
'''